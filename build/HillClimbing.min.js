var t={d:(e,r)=>{for(var o in r)t.o(r,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:r[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{Z:()=>r});const r=class{constructor(t,e={startScore:-1/0,numberOfMutations:1}){if(void 0===t)throw new Error("You must pass a list of targets");if(0===t.length)throw new Error("You must pass at least one target");if(t.forEach((t=>{if("object"!=typeof t)throw new Error("You must pass a list of targets");if(void 0===t.name||"string"!=typeof t.name)throw new Error("You must pass a name (String) for each target");if(void 0===t.value||"number"!=typeof t.value)throw new Error("You must pass a value (Number) for each target");if(void 0===t.min||"number"!=typeof t.min)throw new Error("You must pass a minimum (Number) value for each target");if(void 0===t.max||"number"!=typeof t.max)throw new Error("You must pass a maximum (Number) value for each target")})),"object"!=typeof e)throw new Error("You must pass an options object");this.targets=t.map((t=>({...t}))),this.bestSolution=t.map((t=>({...t}))),this.currentSolution=t.map((t=>({...t}))),this.lastTargetsChanged=[],this.lastScore=e.startScore,this.numberOfIterations=0,this.bestScore=e.startScore,this.numberOfMutations=e.numberOfMutations,this.iterationsData=[{iteration:this.numberOfIterations,score:e.startScore,changedTargets:this.lastTargetsChanged,solution:this.currentSolution}],this._startScore=e.startScore}addTarget(t){if(void 0===t)throw new Error("You must pass a target");if("object"!=typeof t)throw new Error("You must pass a target");if(void 0===t.name||"string"!=typeof t.name)throw new Error("You must pass a name with the type String");if(void 0===t.value||"number"!=typeof t.value)throw new Error("You must pass a value with the type Number");if(void 0===t.min||"number"!=typeof t.min)throw new Error("You must pass a minimum with the type Number");if(void 0===t.max||"number"!=typeof t.max)throw new Error("You must pass a maximum with the type Number");this.targets.push(t),this.bestSolution.push(t),this.currentSolution.push(t)}setAllTargets(t){if(void 0===t)throw new Error("You must pass a list of targets");if(0===t.length)throw new Error("You must pass at least one target");t.forEach((t=>{if("object"!=typeof t)throw new Error("You must pass a list of targets");if(void 0===t.name||"string"!=typeof t.name)throw new Error("You must pass a name (String) for each target");if(void 0===t.value||"number"!=typeof t.value)throw new Error("You must pass a value (Number) for each target");if(void 0===t.min||"number"!=typeof t.min)throw new Error("You must pass a minimum (Number) value for each target");if(void 0===t.max||"number"!=typeof t.max)throw new Error("You must pass a maximum (Number) value for each target")})),this.targets=t,this.bestSolution=t,this.currentSolution=t}removeTarget(t){if(void 0===t)throw new Error("You must pass a name");if("string"!=typeof t)throw new Error("You must pass a name with the type String");const e=this.targets.findIndex((e=>e.name===t));e>-1&&(this.targets.splice(e,1),this.bestSolution.splice(e,1),this.currentSolution.splice(e,1))}setTargetProperty(t,e,r){if(void 0===t)throw new Error("You must pass a target name");if(void 0===e)throw new Error("You must pass a property name to change");if(void 0===r)throw new Error("You must pass a value to change");const o=this.targets.findIndex((e=>e.name===t));if(o<0)throw new Error(`Target ${t} not found`);o>-1&&(this.targets[o][e]=r,this.bestSolution[o][e]=r,this.currentSolution[o][e]=r)}setTargetName(t,e){this.setTargetProperty(t,"name",e)}setTargetMin(t,e){this.setTargetProperty(t,"min",e)}setTargetMax(t,e){this.setTargetProperty(t,"max",e)}setTargetPrecision(t,e){this.setTargetProperty(t,"precision",e)}getNumberOfIterations(){return this.numberOfIterations}getBestScore(){return this.bestScore}getTargets(){return this.targets.map((t=>({...t})))}getBestSolution(){return this.bestSolution.map((t=>({...t})))}getBestSolutionValues(){return this.bestSolution.map((t=>t.value))}getCurrentSolution(){return this.currentSolution.map((t=>({...t})))}getCurrentSolutionValues(){return this.currentSolution.map((t=>t.value))}getCurrentTargetValueSolutionByName(t){if(void 0===t)throw new Error("You must pass a target name");if("string"!=typeof t)throw new Error("The target name must be a string");return this.currentSolution.find((e=>e.name===t)).value}getBestTargetValueSolutionByName(t){if(void 0===t)throw new Error("You must pass a target name");if("string"!=typeof t)throw new Error("The target name must be a string");return this.bestSolution.find((e=>e.name===t)).value}getLastTargetsChanged(){return this.lastTargetsChanged.map((t=>({...t})))}run(t=-1/0){this.numberOfIterations++,this.lastTargetsChanged=[],this.lastScore=t,t>this.bestScore?(this.bestScore=t,this.bestSolution=this.currentSolution.map((t=>({...t})))):this.currentSolution=this.bestSolution.map((t=>({...t})));for(let t=0;t<this.numberOfMutations;t++){let t=this.randomNumber(0,this.bestSolution.length-1);const e={...this.bestSolution[t]};this.lastTargetsChanged.push(e),this.currentSolution[t].value=this.randomNumber(e.min,e.max,e.precision)}const e=this.currentSolution.map((t=>({...t})));return this.iterationsData.push({iteration:this.numberOfIterations,score:t,changedTarget:this.lastTargetsChanged,solution:e}),e}exportData(t=!1){return t?JSON.stringify(this.iterationsData):this.iterationsData}reset(){this.numberOfIterations=0,this.bestSolution=this.targets.map((t=>({...t}))),this.currentSolution=this.targets.map((t=>({...t}))),this.lastTargetsChanged=[],this.bestScore=this._startScore,this.lastScore=this._startScore,this.iterationsData=[]}randomNumber(t=0,e=1,r=0){if("number"!=typeof t)throw new Error("The minimum number must be a number");if("number"!=typeof e)throw new Error("The maximum number must be a number");if("number"!=typeof r)throw new Error("The precision number must be a number");if(t>e)throw new Error("The minimum number must be less than the maximum number");return parseFloat((Math.random()*(e-t)+t).toFixed(r))}static getVersion(){return"1.0.0"}};var o=e.Z;export{o as default};